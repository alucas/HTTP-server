#define _XOPEN_SOURCE 500
#define BUFFER_SIZE 1024

#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <errno.h>
#include <stdbool.h>
#include <dirent.h>
#include <time.h>
#include <pthread.h>

#include "global.h"
#include "requete.h"
#include "sendrecv.h"
#include "client.h"

#define SIZE_PATH 1024
#define DECODE_DEBUG 1

typedef struct request {
  int method;
  char path[BUFFER_SIZE];
  char host[BUFFER_SIZE];
  char agent[BUFFER_SIZE];
  char referer[BUFFER_SIZE];
  char language[BUFFER_SIZE];
  char charset[BUFFER_SIZE];
  char encoding[BUFFER_SIZE];
  char cache_control[BUFFER_SIZE];
  char accept[BUFFER_SIZE];
  int protocol;
  int index;
  int keep_alive;
  int alive_time;
} request_t;

typedef struct reponse {
  int code;
  char content_type[30];
  int lenght;
} reponse_t;


/* Fonction qui gere les erreurs */
static void erreur(int code, reponse_t *rep)
{
  switch(code)
    {
    case 400 :
      printf("Erreur 400 : Bad Request !\n");
      break;
    case 403 :
      printf("Erreur 403 : Forbidden\n");
      break;
    case 404 :
      printf("Erreur 404 : File not found ! (Try Again)\n");
      break;
    case 414 :
      printf("Erreur 414 : Request-URI Too Long\n");
      break;
    case 501 :
      printf("Erreur 501 : Commande non suportée\n");
      break;
    default :
      printf("Erreur interne : Code d'erreur inconnu !\n");
    }
  rep->code = code;
}

/* Fonction qui convertit la chaine de caracteres en une liste de mots
   et les rentre dans la structure de requete passé en parametre */
static int decode(buffer_t *input, request_t *req, reponse_t *rep){
  char buffer[BUFFER_SIZE + 1];
  int mot = 0;
  int ligne = 0;
  int curseur = 0;
  int car_vide = true; // sert a suprimer les espaces consecutifs
  int entete = -1;
  int sum = 0;

  for(int i=0; i<input->use; i++){
    if(input->ptr[i] == ' ' || input->ptr[i] == '\r' || input->ptr[i] == '\n'){
      if(!car_vide){
	car_vide = true;
	buffer[curseur] = '\0';
	if(input->ptr[i] == '\n'){
	  ligne++;
	}
	
	switch(mot){
	case 0 :
	  // ~ table de hashage \o/
	  sum = 0;
	  for(char *c = buffer; (*c) != '\0'; c++){
	    sum += *c;
	  }
 
	  switch(sum){
	  case 224: // GET
	    req->method = 1;
	    break;
	  case 274: // HEAD
	    erreur(501,rep);
	    return 501;
	  case 326: // POST
	    erreur(501,rep);
	    return 501;
	  case 556: // OPTIONS
	    erreur(501,rep);
	    return 501;
	  case 522: // CONNECT
	    erreur(501,rep);
	    return 501;
	  case 367: // TRACE
	    erreur(501,rep);
	    return 501;
	  case 249: // PUT
	    erreur(501,rep);
	    return 501;
	  case 435: // DELETE
	    erreur(501,rep);
	    return 501;
	  default:
	    fprintf(stderr, "commande inconue %s\n", buffer);
	    erreur(400,rep);
	    return 400; // commande inconue
	  }
	  break;

	case 1 :
	  if(curseur <= SIZE_PATH){
	    strncpy(req->path, buffer, (curseur+1)*sizeof(char));
	    
	    break;
	  }

	  erreur(414,rep);
	  return 414; // path trop long
	case 2 :
	  if(!strncmp(buffer, "HTTP/1.", 7) && buffer[8] == '\0'){
	    if(buffer[7] == '0'){
	      req->protocol = 1; // http 1.0
	      break;
	    }else if(buffer[7] == '1'){
	      req->protocol = 2; // http 1.1
	      req->keep_alive = 1;
	      break;
	    }
	  }
	  
	  req->protocol = 0; // http 0.9
	  return 0;
	default :

	  if(DECODE_DEBUG)
	    printf("<decode> mot n°%d (entete : %d) : %s\n", mot+1, entete, buffer);

	  if (buffer[curseur-1] == ':'){
	    if(DECODE_DEBUG)
	      printf("<decode> ':' detecté\n");

	    if       (!strncmp(buffer, "User-Agent", 10)){
	      entete = 1;
	    }else if (!strncmp(buffer, "Host", 4)){
	      entete = 2;
	    }else if (!strncmp(buffer, "Connection", 10)){
	      entete = 3;
	    }else if (!strncmp(buffer, "Keep-Alive", 10)){
	      entete = 4;
	    }else if (!strncmp(buffer, "Referer", 7)){
	      entete = 5;
	    }else if (!strncmp(buffer, "Accept-Language", 15)){
	      entete = 6;
	    }else if (!strncmp(buffer, "Accept-Encoding", 15)){
	      entete = 7;
	    }else if (!strncmp(buffer, "Accept-Charset", 14)){
	      entete = 8;
	    }else if (!strncmp(buffer, "Cache-Control", 13)){
	      entete = 9;
	    }else if (!strncmp(buffer, "Accept", 6)){
	      entete = 10;
	    }else{
	      fprintf(stderr, "parametre %s inconu\n", buffer);
	      entete = 0;
	    }
	  }else{
	    switch(entete){
	    case 0 :
	      break;

	    case 1 :
	      if(strlen(req->agent) == 0){
		strncpy(req->agent, buffer, curseur);
	      }else{
		strncat(req->agent, " ", 1);
		strncat(req->agent, buffer, curseur);
	      }
	      break;

	    case 2 :
	      strncpy(req->host, buffer, curseur);
	      break;

	    case 3 :
	      if (!strncmp(buffer, "keep-alive", 10)){
		req->keep_alive = 1;
	      }
	      break;

	    case 4 :
	      req->alive_time = atoi(buffer);
	      break;

	    case 5 :
	      strncpy(req->referer, buffer, curseur);
	      break;

	    case 6 :
	      strncpy(req->language, buffer, curseur);
	      break;

	    case 7 :
	      strncpy(req->encoding, buffer, curseur);
	      break;

	    case 8 :
	      strncpy(req->charset, buffer, curseur);
	      break;

	    case 9 :
	      strncpy(req->cache_control, buffer, curseur);
	      break;

	    case 10 :
	      strncpy(req->accept, buffer, curseur);
	      break;
	    }
	  }
	}
	
	curseur = 0;
	mot++;
      }
    }else{
      car_vide = false;
      buffer[curseur++] = input->ptr[i];

      if(curseur > BUFFER_SIZE){
	fprintf(stderr, "mot trop long (size max : %d)\n", BUFFER_SIZE);
	return 413; // mot trop long
      }
    }
  }

  if(mot < 2){
    erreur(400,rep);
    return 400;
  }

  return 0;
}

static int valider_path(request_t *requ, reponse_t *rep)
{
  char complete_path[PATH_MAX] = {0};
  /* On cherche le path complet du dossier de depot */
  if(realpath(gl_www.ptr,complete_path) == NULL)
    erreur(404,rep);
  /* Sauvegarde du path racine */
  char save_path[PATH_MAX] = {0};
  strncpy(save_path,complete_path,strlen(complete_path));
  /* On obtient le chemin complet de la ressource */
  strncat(complete_path,requ->path,strlen(requ->path));

  char resolved_path[PATH_MAX] = {0};
  /* On evalue le path complet de la ressource */
  if(realpath(complete_path,resolved_path) == NULL)
    erreur(404,rep);

  if(strncmp(resolved_path,save_path,strlen(save_path)))
    return 0; /* Mauvais path */
  strcpy(requ->path,resolved_path);
  return 1; /* Bon path */
}

/* Evalue la longueur du fichier et si le fichier n'existe pas
   lance une erreur 404 */
static void get_lenght(request_t *requ, reponse_t *rep)
{
  FILE *f;
  if((f = fopen(requ->path,"r")) == NULL)
    {
      erreur(404,rep);
    }
  else
    {
      fseek(f,0,SEEK_END);
      rep->lenght = ftell(f);
    }
  fclose(f);
}


/* Fonction qui forme l'entete de la reponse HTTP */
static void encoder(char *output, reponse_t *rep)
{
  /*HTTP/1.0 <code> <message>*/
  strncat(output,"HTTP/1.0 ",9);
  char buff[4] = {0};
  snprintf(buff, 4, "%d", rep->code);
  strncat(output,buff,3);
  switch(rep->code)
    {
    case 200 :
      strncat(output," OK\n",4);
      break;
    case 201 :
      strncat(output," Created\n",9);
      break;
    case 400 :
      strncat(output," Bad Request\n",13);
      break;
    case 403 :
      strncat(output," Forbidden\n",11);
      break;
    case 404 :
      strncat(output," Not Found\n",11);
      break;
    case 413 :
      strncat(output," Request Entity Too Large\n",26);
      break;
    case 414 :
      strncat(output," Request-URI Too Long\n",22);
      break;
    case 500 :
      strncat(output," Internal Server Error\n",23);
      break;
    case 501 :
      strncat(output," Not Implemented\n",17);
      break;
    }

  if(rep->code < 400){
    /*Date*/
    
    /*Content-Length*/
    if (rep->lenght != -1)
      {
	strcat(output,"Content-Length: ");
	char lenght_buff[10] = {0};
	sprintf(lenght_buff,"%d", rep->lenght);
	strcat(output,lenght_buff);
	strcat(output,"\n");
      }
    /*Content-type*/
    if (rep->content_type != NULL)
      {
	strcat(output,"Content-Type: ");
	strcat(output,rep->content_type);
	strcat(output,"\n");
	printf("<encoder> content-type : %s\n",rep->content_type);
      }
    strcat(output,"\0");
  }
}

static int index_in_dir(request_t *requ, reponse_t *rep)
{
  int i = 0;
  FILE *f;
  buffer_t index_path = bufinit(NULL, BUFFER_SIZE, requ->path, strlen(requ->path));
  strncat(index_path.ptr,"/index.htm",10);
  if((f = fopen(index_path.ptr,"r")) != NULL){
    strncpy(requ->path,index_path.ptr,index_path.siz);
    fclose(f);
    i = 1;
  }
  strncat(index_path.ptr,"l",1);
  if((f = fopen(index_path.ptr,"r")) != NULL){
    strncpy(requ->path,index_path.ptr,index_path.siz);
    fclose(f);
    i = 1;
  }
  printf("<index_in_dir> (i,index_path) :\n(%d,%s)\n",i,index_path.ptr);
  bufkill(&index_path);
  return i;
}

int is_in_cgi_dir(char *path)
{
  /* ? Définir une globale CGI_PATH ? */
  return strncmp(path,"/www/cgi-bin/",12) == 0;
}

static void get_content_type(request_t *requ, reponse_t *rep)
{
  printf("<get_content_type> path :\n%s\n",requ->path);

  int index = 0;
  int i = strlen(requ->path);
  while(i > 0 && requ->path[i] != '.'){
    if(requ->path[i] == '/'){
      i = strlen(requ->path) - i;
      if(!index_in_dir(requ,rep))
	requ->index = 1;
      else
	index = 1;
      break;
    }
    i--;
  }
  char *ext;
  if (requ->index || index){
    ext = "html";
  }else if (i != 0){
    ext = &requ->path[i+1];
  }else{
    ext = "";
  }
  printf("<get_content_type> Extention lue : %s\n",ext);

  if(!strncmp(ext,"html",3))
    strcpy(rep->content_type,"text/html");
  else if(!strncmp(ext,"cpp",3)){
    strcpy(rep->content_type,"text/html");
    requ->index = 3;
  }
  else if(!strcmp(ext,"gif"))
    strcpy(rep->content_type,"image/gif");
  else if(!strcmp(ext,"png") || !strcmp(ext,"ico"))
    strcpy(rep->content_type,"image/png");
  else if(!strncmp(ext,"jpeg",2))
    strcpy(rep->content_type,"image/jpeg");
  else if(!strcmp(ext,"txt") || !strcmp(ext,"c") || !strcmp(ext,"h"))
    strcpy(rep->content_type,"text/plain");
  else if(!strcmp(ext,"")){
    if(is_in_cgi_dir(requ->path)){
      strcpy(rep->content_type,"text/html");
      requ->index = 2;
    } else {
      strcpy(rep->content_type,"text/plain");
    }
  }
  printf("<get_content_type> Content_type: %s\n",rep->content_type);
}

//Date, addresse IP, nom de domaine du client,
//User-Agent, fichier demandé, resultat

/* static void make_log(request_t *requ, reponse_t *rep) */
/* { */
/*   FILE *f; */
/*   char log_path[BUFFER_SIZE] = {0}; */
/*   char real_log_path[PATH_MAX] = {0}; */
/*   time_t t = time(NULL); */
/*   char *log_time = ctime(&t); */

/*   strncpy(log_path,gl_www.ptr,gl_www.siz); */
/*   strncat(log_path,"serveur.log",12); */
/*   if(realpath(log_path,real_log_path) != NULL){ */

/*     f = fopen("/serveur.log","w"); */
/*     fwrite("\n",sizeof(char),2,f); */
/*     fwrite(log_time,sizeof(char),strlen(log_time),f); */
/*     fwrite("Host: ",sizeof(char),6,f); */
/*     fwrite(requ->host,sizeof(char),strlen(requ->host),f); */
/*     fclose(f); */
/*   } */
/*   printf("%s\n",real_log_path); */

/* } */


/* Fonction qui interprete une requette passee en parametre dans input,
   fournit le chemin du fichier demandé dans path,
   fournit le header dans output,
   précise s'il faut generer un index du dossier dans index (0/1) 
   précise s'il faut conserver la connection dans keep_alive (0/1) */
int interpreter(buffer_t *path, buffer_t *input, buffer_t *output, int *index, int *keep_alive)
{
  request_t requete = {0, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, 0, 0, 0, 0};
  reponse_t reponse = {200, {0}, 10};

  printf("<interpreter> requete entrante (taille : %d/%d) :\n'%s'\n", input->use, strlen(input->ptr), input->ptr);

  decode(input, &requete, &reponse);

  if(!valider_path(&requete,&reponse)){
    reponse.lenght = -1;
    erreur(403,&reponse);
  }
  if(reponse.code == 200){
    get_content_type(&requete, &reponse);
    strncpy(path->ptr,requete.path, strlen(requete.path));
    *index = requete.index;
    path->ptr[strlen(requete.path)] = '\0';
  }
  if(reponse.code == 200 && requete.index == 0){
    get_lenght(&requete, &reponse);
  }
  encoder(output->ptr, &reponse);
  output->use = strlen(output->ptr);

  //make_log(&requete,&reponse);

  *keep_alive = requete.keep_alive;
  return reponse.code;
}

void supprimerRequete(buffer_t *requete, int posFin){
  assert(posFin <= requete->use);

  memmove(requete->ptr, requete->ptr + posFin, requete->use - posFin);
  requete->use -= posFin; 
}

void *traiterRequete(void *param){
  client_t *client = (client_t *)param;
  int keep_alive = 0;
  int index = 0;
  int ret = 0;
  int end = 0;

  if(client->requete.ptr == NULL) client->requete = bufinit(&client->requete, BUFFER_SIZE, "", 0);
  if(client->reponse.ptr == NULL) client->reponse = bufinit(&client->reponse, BUFFER_SIZE, "", 0);
  if(client->path.ptr == NULL) client->path = bufinit(&client->path, BUFFER_SIZE, "", 0);
  
  if(pthread_detach(client->thread) != 0){
    perror("pthread_detach");
    return NULL;
  }

  client->requete.use = 0;
  while((ret = readRequete(&client->requete, client->sock, &end, true)) != -1){
    printf("<traiterRequete> code de retour de readRequete : %d\n", ret);
    
    if(ret == 0){
      ret = interpreter(&client->path, &client->requete, &client->reponse, &index, &keep_alive);
      supprimerRequete(&client->requete, end);
    }else{
      client->requete.use = 0;
    }
    
    printf("<traiterRequete> path : '%s'\n", client->path.ptr);

    if(ret >= 400){
      sendErreur(&client->reponse, ret, client->sock);
    }else{
      sendReponse(&client->reponse, &client->path, client->sock, index);
    }
    
    if(gl_close != 0){
      client->uptime = time(NULL); //A voir : utiliser le champ
				   //alive_time de la struct requete ?
    }

    if(DECODE_DEBUG)printf("<traiterRequete> keep_alive = %d (1 oui, 0 non )\n",keep_alive);
    /* J'ai commenté cette ligne sinon le while boucle a l'infini sur
       la requette, décommente la ligne si tu veut voir, moi ca m'a
       surpris :D */
    if(!keep_alive){
      break;
    }
  }
  
  printf("<traiterRequete> déconnexion du client %s:%s (socket %d)\n", client->host, client->serv, client->sock);
  deconnexionClient(client);

  return NULL;
}
